src/dynarec/arm64/dynarec_arm64_00.c:                        ADDx_U12(x1, xEmu, (uint32_t)offsetof(x64emu_t, ip)); // setup addr as &emu->ip
src/dynarec/arm64/dynarec_arm64_00.c:                        ADDx_U12(x1, xEmu, (uint32_t)offsetof(x64emu_t, ip)); // setup addr as &emu->ip
src/dynarec/arm64/dynarec_arm64_0f.c:            /*emu->top = 0;
src/dynarec/arm64/dynarec_arm64_0f.c:            emu->fpu_stack = 0;*/ //TODO: Check if something is needed here?
src/dynarec/arm64/dynarec_arm64_emit_tests.c:    // PF: (((emu->x64emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)
src/dynarec/arm64/dynarec_arm64_emit_tests.c:    // PF: (((emu->x64emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)
src/dynarec/arm64/dynarec_arm64_emit_tests.c:    // PF: (((emu->x64emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + st)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + st)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s3, s3, 0, 2); //mask=7   // (emu->top + st)&7
src/dynarec/arm64/dynarec_arm64_helper.c:            ANDw_mask(s3, s3, 0, 2); // mask=7   // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:        ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:        ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:            ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:    ANDw_mask(s2, s2, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s3, s3, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s3, s3, 0, 2); //mask=7    // (emu->top + i)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s3, s3, 0, 2);    // (emu->top + st)&7
src/dynarec/arm64/dynarec_arm64_helper.c:                ANDw_mask(s3, s3, 0, 2);    // (emu->top + st)&7
src/dynarec/arm64/dynarec_arm64_helper.c:    // PF: (((emu->x64emu_parity_tab[(res) / 32] >> ((res) % 32)) & 1) == 0)
src/dynarec/dynablock.c:            emu->test.test = 0;
src/dynarec/dynablock.c:        emu->test.test = 0;
src/dynarec/dynablock.c:        emu->test.test = 0;
src/dynarec/dynarec.c:    struct __jmp_buf_tag *old_jmpbuf = emu->jmpbuf;
src/dynarec/dynarec.c:    emu->jmpbuf = jmpbuf;
src/dynarec/dynarec.c:    if((skip = sigsetjmp(emu->jmpbuf, 1))) {
src/dynarec/dynarec.c:        printf_log(LOG_DEBUG, "Setjmp DynaCall, fs=0x%x\n", emu->segs[_FS]);
src/dynarec/dynarec.c:            if(emu->test.clean)
src/dynarec/dynarec.c:            emu->test.clean = 0;
src/dynarec/dynarec.c:        emu->df = d_none;
src/dynarec/dynarec.c:        while(!emu->quit) {
src/dynarec/dynarec.c:            int is32bits = (emu->segs[_CS]==0x23);
src/dynarec/dynarec.c:                    emu->test.clean = 0;
src/dynarec/dynarec.c:            if(emu->fork) {
src/dynarec/dynarec.c:                int forktype = emu->fork;
src/dynarec/dynarec.c:                emu->quit = 0;
src/dynarec/dynarec.c:                emu->fork = 0;
src/dynarec/dynarec.c:        emu->quit = 0;  // reset Quit flags...
src/dynarec/dynarec.c:        emu->df = d_none;
src/dynarec/dynarec.c:        if(emu->quitonlongjmp && emu->longjmp) {
src/dynarec/dynarec.c:            if(emu->quitonlongjmp==1)
src/dynarec/dynarec.c:                emu->longjmp = 0;   // don't change anything because of the longjmp
src/dynarec/dynarec.c:    emu->jmpbuf = old_jmpbuf;
src/dynarec/dynarec.c:    struct __jmp_buf_tag *old_jmpbuf = emu->jmpbuf;
src/dynarec/dynarec.c:    emu->jmpbuf = jmpbuf;
src/dynarec/dynarec.c:    if((skip=sigsetjmp(emu->jmpbuf, 1))) {
src/dynarec/dynarec.c:        printf_log(LOG_DEBUG, "Setjmp DynaRun, fs=0x%x\n", emu->segs[_FS]);
src/dynarec/dynarec.c:            if(emu->test.clean)
src/dynarec/dynarec.c:            emu->test.clean = 0;
src/dynarec/dynarec.c:        while(!emu->quit) {
src/dynarec/dynarec.c:            int is32bits = (emu->segs[_CS]==0x23);
src/dynarec/dynarec.c:                    emu->test.clean = 0;
src/dynarec/dynarec.c:            if(emu->fork) {
src/dynarec/dynarec.c:                int forktype = emu->fork;
src/dynarec/dynarec.c:                emu->quit = 0;
src/dynarec/dynarec.c:                emu->fork = 0;
src/dynarec/dynarec.c:    emu->jmpbuf = old_jmpbuf;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C1 = (tmp32s&1);
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C3 = ((tmp32s>>1)&1);
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C0 = ((tmp32s>>2)&1);
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:        emu->test.test = 0;
src/dynarec/dynarec_native_functions.c:    emu->test.test = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C2 = 0;
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C1 = (tmp32s&1);
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C3 = ((tmp32s>>1)&1);
src/dynarec/dynarec_native_functions.c:    emu->sw.f.F87_C0 = ((tmp32s>>2)&1);
src/dynarec/dynarec_native_functions.c:    sse_regs_t eax1 = emu->xmm[xmm];
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[0+j*4] = ff_mult(0x0E, eax1.ub[0+j*4]) ^ ff_mult(0x0B, eax1.ub[1+j*4]) ^ ff_mult(0x0D, eax1.ub[2+j*4]) ^ ff_mult(0x09, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[1+j*4] = ff_mult(0x09, eax1.ub[0+j*4]) ^ ff_mult(0x0E, eax1.ub[1+j*4]) ^ ff_mult(0x0B, eax1.ub[2+j*4]) ^ ff_mult(0x0D, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[2+j*4] = ff_mult(0x0D, eax1.ub[0+j*4]) ^ ff_mult(0x09, eax1.ub[1+j*4]) ^ ff_mult(0x0E, eax1.ub[2+j*4]) ^ ff_mult(0x0B, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[3+j*4] = ff_mult(0x0B, eax1.ub[0+j*4]) ^ ff_mult(0x0D, eax1.ub[1+j*4]) ^ ff_mult(0x09, eax1.ub[2+j*4]) ^ ff_mult(0x0E, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:    sse_regs_t eax1 = emu->xmm[xmm];
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[0+j*4] = ff_mult(0x02, eax1.ub[0+j*4]) ^ ff_mult(0x03, eax1.ub[1+j*4]) ^               eax1.ub[2+j*4]  ^               eax1.ub[3+j*4] ;
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[1+j*4] =               eax1.ub[0+j*4]  ^ ff_mult(0x02, eax1.ub[1+j*4]) ^ ff_mult(0x03, eax1.ub[2+j*4]) ^               eax1.ub[3+j*4] ;
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[2+j*4] =               eax1.ub[0+j*4]  ^               eax1.ub[1+j*4]  ^ ff_mult(0x02, eax1.ub[2+j*4]) ^ ff_mult(0x03, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[3+j*4] = ff_mult(0x03, eax1.ub[0+j*4]) ^               eax1.ub[1+j*4]  ^               eax1.ub[2+j*4]  ^ ff_mult(0x02, eax1.ub[3+j*4]);
src/dynarec/dynarec_native_functions.c:        eax1.ub[i] = emu->xmm[xmm].ub[invshiftrows[i]];
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[i] = invsubbytes[eax1.ub[i]];
src/dynarec/dynarec_native_functions.c:        eax1.ub[i] = emu->xmm[xmm].ub[shiftrows[i]];
src/dynarec/dynarec_native_functions.c:        emu->xmm[xmm].ub[i] = subbytes[eax1.ub[i]];
src/dynarec/dynarec_native_functions.c:    sse_regs_t *EX = p?((sse_regs_t*)p):&emu->xmm[ex];
src/dynarec/dynarec_native_functions.c:    sse_regs_t *GX = &emu->xmm[gx];
src/dynarec/dynarec_native_functions.c:    sse_regs_t *EX = p?((sse_regs_t*)p):&emu->xmm[ex];
src/dynarec/dynarec_native_functions.c:    sse_regs_t *GX = &emu->xmm[gx];
src/emu/x64emu.c:    emu->context = context;
src/emu/x64emu.c:        emu->sbiidx[i] = &emu->regs[i];
src/emu/x64emu.c:    emu->sbiidx[4] = &emu->zero;
src/emu/x64emu.c:    emu->x64emu_parity_tab = x86emu_parity_tab;
src/emu/x64emu.c:    emu->eflags.x64 = 0x202; // default flags?
src/emu/x64emu.c:    emu->stack2free = (ownstack)?(void*)stack:NULL;
src/emu/x64emu.c:    emu->init_stack = (void*)stack;
src/emu/x64emu.c:    emu->size_stack = stacksize;
src/emu/x64emu.c:    emu->segs[_CS] = 0x33;
src/emu/x64emu.c:    emu->segs[_DS] = emu->segs[_ES] = emu->segs[_SS] = 0x2b;
src/emu/x64emu.c:    emu->segs[_FS] = 0x43;
src/emu/x64emu.c:    emu->segs[_GS] = default_gs;
src/emu/x64emu.c:    emu->mxcsr.x32 = 0x1f80;
src/emu/x64emu.c:    if(emu && emu->stack2free)
src/emu/x64emu.c:        my_munmap(NULL, emu->stack2free, emu->size_stack);
src/emu/x64emu.c:	memcpy(newemu->regs, emu->regs, sizeof(emu->regs));
src/emu/x64emu.c:    memcpy(&newemu->ip, &emu->ip, sizeof(emu->ip));
src/emu/x64emu.c:	memcpy(&newemu->eflags, &emu->eflags, sizeof(emu->eflags));
src/emu/x64emu.c:    newemu->old_ip = emu->old_ip;
src/emu/x64emu.c:    memcpy(newemu->segs, emu->segs, sizeof(emu->segs));
src/emu/x64emu.c:    memset(newemu->segs_serial, 0, sizeof(newemu->segs_serial));
src/emu/x64emu.c:	memcpy(newemu->x87, emu->x87, sizeof(emu->x87));
src/emu/x64emu.c:	memcpy(newemu->mmx, emu->mmx, sizeof(emu->mmx));
src/emu/x64emu.c:    memcpy(newemu->fpu_ld, emu->fpu_ld, sizeof(emu->fpu_ld));
src/emu/x64emu.c:    memcpy(newemu->fpu_ll, emu->fpu_ll, sizeof(emu->fpu_ll));
src/emu/x64emu.c:	memcpy(newemu->p_regs, emu->p_regs, sizeof(emu->p_regs));
src/emu/x64emu.c:	newemu->cw = emu->cw;
src/emu/x64emu.c:	newemu->sw = emu->sw;
src/emu/x64emu.c:	newemu->top = emu->top;
src/emu/x64emu.c:    newemu->fpu_stack = emu->fpu_stack;
src/emu/x64emu.c:    memcpy(newemu->xmm, emu->xmm, sizeof(emu->xmm));
src/emu/x64emu.c:    newemu->df = emu->df;
src/emu/x64emu.c:    newemu->df_sav = emu->df_sav;
src/emu/x64emu.c:    newemu->op1 = emu->op1;
src/emu/x64emu.c:    newemu->op2 = emu->op2;
src/emu/x64emu.c:    newemu->res = emu->res;
src/emu/x64emu.c:    newemu->op1_sav = emu->op1_sav;
src/emu/x64emu.c:    newemu->res_sav = emu->res_sav;
src/emu/x64emu.c:    newemu->mxcsr = emu->mxcsr;
src/emu/x64emu.c:    newemu->quit = emu->quit;
src/emu/x64emu.c:    newemu->error = emu->error;
src/emu/x64emu.c:    uintptr_t oldst = (uintptr_t)((emu->init_stack)?emu->init_stack:emu->context->stack);
src/emu/x64emu.c:    uintptr_t newst = (uintptr_t)((newemu->init_stack)?newemu->init_stack:newemu->context->stack);
src/emu/x64emu.c:    newemu->regs[_SP].q[0] = emu->regs[_SP].q[0] + (intptr_t)(newst - oldst);
src/emu/x64emu.c:	memcpy(newemu->regs, emu->regs, sizeof(emu->regs));
src/emu/x64emu.c:    memcpy(&newemu->ip, &emu->ip, sizeof(emu->ip));
src/emu/x64emu.c:	memcpy(&newemu->eflags, &emu->eflags, sizeof(emu->eflags));
src/emu/x64emu.c:    newemu->old_ip = emu->old_ip;
src/emu/x64emu.c:    memcpy(newemu->segs, emu->segs, sizeof(emu->segs));
src/emu/x64emu.c:    memcpy(newemu->segs_serial, emu->segs_serial, sizeof(emu->segs_serial));
src/emu/x64emu.c:    memcpy(newemu->segs_offs, emu->segs_offs, sizeof(emu->segs_offs));
src/emu/x64emu.c:	memcpy(newemu->x87, emu->x87, sizeof(emu->x87));
src/emu/x64emu.c:	memcpy(newemu->mmx, emu->mmx, sizeof(emu->mmx));
src/emu/x64emu.c:    memcpy(newemu->xmm, emu->xmm, sizeof(emu->xmm));
src/emu/x64emu.c:    memcpy(newemu->fpu_ld, emu->fpu_ld, sizeof(emu->fpu_ld));
src/emu/x64emu.c:    memcpy(newemu->fpu_ll, emu->fpu_ll, sizeof(emu->fpu_ll));
src/emu/x64emu.c:	memcpy(newemu->p_regs, emu->p_regs, sizeof(emu->p_regs));
src/emu/x64emu.c:	newemu->cw = emu->cw;
src/emu/x64emu.c:	newemu->sw = emu->sw;
src/emu/x64emu.c:	newemu->top = emu->top;
src/emu/x64emu.c:    newemu->fpu_stack = emu->fpu_stack;
src/emu/x64emu.c:    newemu->df = emu->df;
src/emu/x64emu.c:    newemu->df_sav = emu->df_sav;
src/emu/x64emu.c:    newemu->op1 = emu->op1;
src/emu/x64emu.c:    newemu->op2 = emu->op2;
src/emu/x64emu.c:    newemu->res = emu->res;
src/emu/x64emu.c:    newemu->op1_sav = emu->op1_sav;
src/emu/x64emu.c:    newemu->res_sav = emu->res_sav;
src/emu/x64emu.c:    newemu->mxcsr = emu->mxcsr;
src/emu/x64emu.c:    newemu->quit = emu->quit;
src/emu/x64emu.c:    newemu->error = emu->error;
src/emu/x64emu.c:    return emu->context;
src/emu/x64emu.c:    emu->segs[_FS] = v;
src/emu/x64emu.c:    emu->segs_serial[_FS] = 0;
src/emu/x64emu.c:    return emu->segs[_FS];
src/emu/x64emu.c:    emu->df = d_none;
src/emu/x64emu.c:            sprintf(tmp, "mm%d:%016lx", i, emu->mmx[i].q);
src/emu/x64emu.c:            if (trace_regsdiff && (emu->old_xmm[i].q[0] != emu->xmm[i].q[0] || emu->old_xmm[i].q[1] != emu->xmm[i].q[1])) {
src/emu/x64emu.c:                sprintf(tmp, "\e[1;35m%02d:%016lx-%016lx\e[m", i, emu->xmm[i].q[1], emu->xmm[i].q[0]);
src/emu/x64emu.c:                emu->old_xmm[i].q[0] = emu->xmm[i].q[0];
src/emu/x64emu.c:                emu->old_xmm[i].q[1] = emu->xmm[i].q[1];
src/emu/x64emu.c:                sprintf(tmp, "%02d:%016lx-%016lx", i, emu->xmm[i].q[1], emu->xmm[i].q[0]);
src/emu/x64emu.c:    if(emu->fpu_stack) {
src/emu/x64emu.c:        for (int i=0; i<emu->fpu_stack; i++) {
src/emu/x64emu.c:            sprintf(tmp, "%s=0x%04x", segname[i], emu->segs[i]);
src/emu/x64emu.c:            if (trace_regsdiff && (emu->regs[i].dword[0] != emu->oldregs[i].q[0])) {
src/emu/x64emu.c:                sprintf(tmp, "\e[1;35m%s=%08x\e[m ", regname32[i], emu->regs[i].dword[0]);
src/emu/x64emu.c:                emu->oldregs[i].q[0] = emu->regs[i].dword[0];
src/emu/x64emu.c:                sprintf(tmp, "%s=%08x ", regname32[i], emu->regs[i].dword[0]);
src/emu/x64emu.c:            sprintf(tmp, "%s=%08x ", regname[i], emu->regs[i].dword[0]);
src/emu/x64emu.c:                if(emu->df) {
src/emu/x64emu.c:            if (trace_regsdiff && (emu->regs[i].q[0] != emu->oldregs[i].q[0])) {
src/emu/x64emu.c:                sprintf(tmp, "\e[1;35m%s=%016lx\e[m ", regname[i], emu->regs[i].q[0]);
src/emu/x64emu.c:                emu->oldregs[i].q[0] = emu->regs[i].q[0];
src/emu/x64emu.c:                sprintf(tmp, "%s=%016lx ", regname[i], emu->regs[i].q[0]);
src/emu/x64emu.c:            sprintf(tmp, "%s=%016lx ", regname[i], emu->regs[i].q[0]);
src/emu/x64emu.c:                    if(emu->df) {
src/emu/x64emu.c:    emu->quit = 1;
src/emu/x64emu.c:    printf_log(LOG_NONE, "Old IP: %tX\n", emu->old_ip);
src/emu/x64emu.c:    printf_log(LOG_NONE, "%s\n", DecodeX64Trace(my_context->dec, emu->old_ip));
src/emu/x64emu.c:    R_RIP = emu->old_ip;
src/emu/x64emu.c:        tid, (void*)emu->old_ip, is32bits?"32bits ":"",
src/emu/x64emu.c:    emu->quit=1;
src/emu/x64emu.c:    emu->error |= ERR_UNIMPL;
src/emu/x64emu.c:    emu->df = d_none;
src/emu/x64emu.c:    emu->quit = 0;  // reset Quit flags...
src/emu/x64emu.c:    emu->df = d_none;
src/emu/x64emu.c:    if(emu->quitonlongjmp && emu->longjmp) {
src/emu/x64emu.c:        if(emu->quitonlongjmp==1)
src/emu/x64emu.c:            emu->longjmp = 0;   // don't change anything because of the longjmp
src/emu/x64emu.c:    memset(emu->segs_serial, 0, sizeof(emu->segs_serial));
src/emu/x64emu.c:    _mm_setcsr(_mm_getcsr() | (emu->mxcsr.x32&0x8040));
src/emu/x64emu.c:    fpcr |= (emu->mxcsr.f.MXCSR_FZ)<<24;  // set FZ as mxcsr FZ
src/emu/x64emu.c:    fpcr |= ((emu->mxcsr.f.MXCSR_DAZ)^(emu->mxcsr.f.MXCSR_FZ))<<1; // set AH if DAZ different from FZ
src/emu/x64emu_private.h://#define INTR_RAISE_DIV0(emu) {emu->error |= ERR_DIVBY0; emu->quit=1;}
src/emu/x64emu_private.h:#define INTR_RAISE_DIV0(emu) {emu->error |= ERR_DIVBY0;} // should rise a SIGFPE and not quit
src/emu/x64int3.c:    int type = emu->type;
src/emu/x64int3.c:        iFpppp_t forkpty = (iFpppp_t)emu->forkpty_info->f;
src/emu/x64int3.c:        v = forkpty(emu->forkpty_info->amaster, emu->forkpty_info->name, emu->forkpty_info->termp, emu->forkpty_info->winp);
src/emu/x64int3.c:        emu->forkpty_info = NULL;
src/emu/x64int3.c:            emu->quit=1; // normal quit
src/emu/x64int3.c:                    mutex_lock(&emu->context->mutex_trace);
src/emu/x64int3.c:                    mutex_unlock(&emu->context->mutex_trace);
src/emu/x64int3.c:                    mutex_lock(&emu->context->mutex_trace);
src/emu/x64int3.c:                    mutex_unlock(&emu->context->mutex_trace);
src/emu/x64int3.c:    //emu->quit = 1;
src/emu/x64primop.c:#define PARITY(x)   (((emu->x64emu_parity_tab[(x) / 32] >> ((x) % 32)) & 1) == 0)
src/emu/x64primop.h:	emu->res.u16 = d + s;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->op2.u8 = s;
src/emu/x64primop.h:	emu->df = d_add8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->res.u32 = d + s;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->op2.u16 = s;
src/emu/x64primop.h:	emu->df = d_add16;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->res.u64 = (uint64_t)d + s;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->op2.u32 = s;
src/emu/x64primop.h:	emu->df = d_add32;
src/emu/x64primop.h:    return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = d + s;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->op2.u64 = s;
src/emu/x64primop.h:	emu->df = d_add64;
src/emu/x64primop.h:    return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = d & s;
src/emu/x64primop.h:	emu->df = d_and8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:    emu->res.u16 = d & s;
src/emu/x64primop.h:	emu->df = d_and16;
src/emu/x64primop.h:    return emu->res.u16;
src/emu/x64primop.h:	emu->res.u32 = d & s;
src/emu/x64primop.h:	emu->df = d_and32;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = d & s;
src/emu/x64primop.h:	emu->df = d_and64;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	if(emu->df>=d_dec8 && emu->df<=d_inc64)	{		\
src/emu/x64primop.h:		emu->df_sav = d_none;						\
src/emu/x64primop.h:	} else if(emu->df<d_dec8i || emu->df>d_inc64i) {\
src/emu/x64primop.h:		emu->df_sav = emu->df;						\
src/emu/x64primop.h:		emu->op1_sav = emu->op1;					\
src/emu/x64primop.h:		emu->res_sav = emu->res;					\
src/emu/x64primop.h:    emu->res.u8 = d - 1;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->df = d_dec8i;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:    emu->res.u16 = d - 1;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->df = d_dec16i;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:    emu->res.u32 = d - 1;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->df = d_dec32i;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:    emu->res.u64 = d - 1;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->df = d_dec64i;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = d + 1;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->df = d_inc8i;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->res.u16 = d + 1;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->df = d_inc16i;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	/*if(emu->df == d_shr32) {
src/emu/x64primop.h:		uint32_t cnt = emu->op2.u32;
src/emu/x64primop.h:            uint32_t cc = emu->op1.u32 & (1 << (cnt - 1));
src/emu/x64primop.h:	emu->res.u32 = d + 1;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->df = d_inc32i;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	/*if(emu->df == d_shr64) {
src/emu/x64primop.h:		uint64_t cnt = emu->op2.u64;
src/emu/x64primop.h:            uint64_t cc = emu->op1.u64 & (1LL << (cnt - 1));
src/emu/x64primop.h:	emu->res.u64 = d + 1;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->df = d_inc64i;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = d | s;
src/emu/x64primop.h:	emu->df = d_or8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->res.u16 = d | s;
src/emu/x64primop.h:	emu->df = d_or16;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->res.u32 = d | s;
src/emu/x64primop.h:	emu->df = d_or32;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = d | s;
src/emu/x64primop.h:	emu->df = d_or64;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = (uint8_t)-s;
src/emu/x64primop.h:	emu->op1.u8 = s;
src/emu/x64primop.h:	emu->df = d_neg8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->res.u16 = (uint16_t)-s;
src/emu/x64primop.h:	emu->op1.u16 = s;
src/emu/x64primop.h:	emu->df = d_neg16;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->res.u32 = (uint32_t)-s;
src/emu/x64primop.h:	emu->op1.u32 = s;
src/emu/x64primop.h:	emu->df = d_neg32;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = (uint64_t)-s;
src/emu/x64primop.h:	emu->op1.u64 = s;
src/emu/x64primop.h:	emu->df = d_neg64;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->df = d_shl8;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->op2.u8 = s;
src/emu/x64primop.h:	emu->res.u8 = d << s;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->df = d_shl16;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->op2.u16 = s;
src/emu/x64primop.h:	emu->res.u16 = d << s;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->df = d_shl32;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->op2.u32 = s;
src/emu/x64primop.h:	emu->res.u32 = d << s;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->df = d_shl64;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->op2.u64 = s;
src/emu/x64primop.h:	emu->res.u64 = d << s;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->df = d_shr8;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->op2.u8 = s;
src/emu/x64primop.h:	emu->res.u8 = d >> s;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->df = d_shr16;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->op2.u16 = s;
src/emu/x64primop.h:	emu->res.u16 = d >> s;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->df = d_shr32;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->op2.u32 = s;
src/emu/x64primop.h:	emu->res.u32 = d >> s;
src/emu/x64primop.h:    return emu->res.u32;
src/emu/x64primop.h:	emu->df = d_shr64;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->op2.u64 = s;
src/emu/x64primop.h:	emu->res.u64 = d >> s;
src/emu/x64primop.h:    return emu->res.u64;
src/emu/x64primop.h:	emu->df = d_sar8;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->op2.u8 = s;
src/emu/x64primop.h:	emu->res.u8 = (uint8_t)(((int8_t)d)>>s);
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->df = d_sar16;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->op2.u16 = s;
src/emu/x64primop.h:	emu->res.u16 = (uint16_t)(((int16_t)d)>>s);
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->df = d_sar32;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->op2.u32 = s;
src/emu/x64primop.h:	emu->res.u32 = (uint32_t)(((int32_t)d)>>s);
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->df = d_sar64;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->op2.u64 = s;
src/emu/x64primop.h:	emu->res.u64 = (uint64_t)(((int64_t)d)>>s);
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = d - s;
src/emu/x64primop.h:	emu->op1.u8 = d;
src/emu/x64primop.h:	emu->op2.u8 = s;
src/emu/x64primop.h:	emu->df = d_sub8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:    emu->res.u16 = d - s;
src/emu/x64primop.h:	emu->op1.u16 = d;
src/emu/x64primop.h:	emu->op2.u16 = s;
src/emu/x64primop.h:	emu->df = d_sub16;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->res.u32 = d - s;
src/emu/x64primop.h:	emu->op1.u32 = d;
src/emu/x64primop.h:	emu->op2.u32 = s;
src/emu/x64primop.h:	emu->df = d_sub32;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = d - s;
src/emu/x64primop.h:	emu->op1.u64 = d;
src/emu/x64primop.h:	emu->op2.u64 = s;
src/emu/x64primop.h:	emu->df = d_sub64;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->res.u8 = d ^ s;
src/emu/x64primop.h:	emu->df = d_xor8;
src/emu/x64primop.h:	return emu->res.u8;
src/emu/x64primop.h:	emu->res.u16 = d ^ s;
src/emu/x64primop.h:	emu->df = d_xor16;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->res.u32 = d ^ s;
src/emu/x64primop.h:	emu->df = d_xor32;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->res.u64 = d ^ s;
src/emu/x64primop.h:	emu->df = d_xor64;
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->df = d_imul8;
src/emu/x64primop.h:	R_AX = emu->res.u16 = (int16_t)(int8_t)R_AL * (int8_t)s;
src/emu/x64primop.h:	emu->df = d_imul16;
src/emu/x64primop.h:	emu->res.u32 = (int32_t)(int16_t)R_AX * (int16_t)s;
src/emu/x64primop.h:	R_AX = (uint16_t)emu->res.u32;
src/emu/x64primop.h:	R_DX = (uint16_t)(emu->res.u32 >> 16);
src/emu/x64primop.h:	emu->df = d_imul16;
src/emu/x64primop.h:	emu->res.u32 = (int32_t)(int16_t)op1 * (int16_t)op2;
src/emu/x64primop.h:	return emu->res.u16;
src/emu/x64primop.h:	emu->df = d_imul32;
src/emu/x64primop.h:	emu->res.u32 = _res;
src/emu/x64primop.h:	emu->op1.u32 = _op1;
src/emu/x64primop.h:	return emu->res.u32;
src/emu/x64primop.h:	emu->df = d_imul32;
src/emu/x64primop.h:	emu->res.u32 = R_EAX;
src/emu/x64primop.h:	emu->op1.u32 = R_EDX;
src/emu/x64primop.h:	emu->df = d_imul64;
src/emu/x64primop.h:	imul64_direct(&emu->res.u64,&emu->op1.u64,op1,op2);
src/emu/x64primop.h:	return emu->res.u64;
src/emu/x64primop.h:	emu->df = d_imul64;
src/emu/x64primop.h:	emu->res.u64 = R_RAX;
src/emu/x64primop.h:	emu->op1.u64 = R_RDX;
src/emu/x64primop.h:	emu->df = d_mul8;
src/emu/x64primop.h:	R_AX = emu->res.u16 = (uint16_t)(R_AL) * s;
src/emu/x64primop.h:	emu->df = d_mul16;
src/emu/x64primop.h:	emu->res.u32 = (uint32_t)R_AX * s;
src/emu/x64primop.h:	R_AX = (uint16_t)emu->res.u32;
src/emu/x64primop.h:	R_DX = (uint16_t)(emu->res.u32 >> 16);
src/emu/x64primop.h:	emu->df = d_mul32;
src/emu/x64primop.h:	emu->res.u32 = R_EAX = (uint32_t)res;
src/emu/x64primop.h:	emu->op1.u32 = R_EDX = (uint32_t)(res >> 32);
src/emu/x64primop.h:	emu->df = d_mul64;
src/emu/x64primop.h:	emu->res.u64 = R_RAX = (uint64_t)res;
src/emu/x64primop.h:	emu->op1.u64 = R_RDX = (uint64_t)(res >> 64);
src/emu/x64run.c:    int is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:    if(emu->quit)
src/emu/x64run.c:        emu->quit = 1;
src/emu/x64run.c:        emu->prev2_ip = emu->old_ip;
src/emu/x64run.c:        emu->old_ip = addr;
src/emu/x64run.c:            Push32(emu, emu->segs[_ES]);  // even if a segment is a 16bits, a 32bits push/pop is done
src/emu/x64run.c:            emu->segs[_ES] = Pop32(emu);    // no check, no use....
src/emu/x64run.c:            emu->segs_serial[_ES] = 0;
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            Push32(emu, emu->segs[_DS]);  // even if a segment is a 16bits, a 32bits push/pop is done
src/emu/x64run.c:            emu->segs[_DS] = Pop32(emu);    // no check, no use....
src/emu/x64run.c:            emu->segs_serial[_DS] = 0;
src/emu/x64run.c:            emu->regs[tmp8u].dword[0] = inc32(emu, emu->regs[tmp8u].dword[0]);
src/emu/x64run.c:            emu->regs[tmp8u].dword[0] = dec32(emu, emu->regs[tmp8u].dword[0]);
src/emu/x64run.c:                Push32(emu, emu->regs[tmp8u].dword[0]);
src/emu/x64run.c:                Push64(emu, emu->regs[tmp8u].q[0]);
src/emu/x64run.c:            emu->regs[tmp8u].q[0] = is32bits?Pop32(emu):Pop64(emu);
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:                pthread_mutex_lock(&emu->context->mutex_lock); // XCHG always LOCK (but when accessing memory only)
src/emu/x64run.c:                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run.c:                pthread_mutex_lock(&emu->context->mutex_lock); // XCHG always LOCK (but when accessing memory only)
src/emu/x64run.c:                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run.c:                ED->q[0] = emu->segs[((nextop&0x38)>>3)];
src/emu/x64run.c:                ED->word[0] = emu->segs[((nextop&0x38)>>3)];
src/emu/x64run.c:            emu->segs[((nextop&0x38)>>3)] = ED->word[0];
src/emu/x64run.c:            emu->segs_serial[((nextop&0x38)>>3)] = 0;
src/emu/x64run.c:                emu->regs[(nextop&7)+(rex.b<<3)].q[0] = rex.is32bits?Pop32(emu):Pop64(emu);
src/emu/x64run.c:                    R_RAX = emu->regs[tmp8u].q[0];
src/emu/x64run.c:                    emu->regs[tmp8u].q[0] = tmp64u;
src/emu/x64run.c:                    R_RAX = emu->regs[tmp8u].dword[0];
src/emu/x64run.c:                    emu->regs[tmp8u].q[0] = tmp64u;
src/emu/x64run.c:                emu->regs[_AX].sq[0] = emu->regs[_AX].sdword[0];
src/emu/x64run.c:                emu->regs[_AX].sdword[0] = emu->regs[_AX].sword[0];
src/emu/x64run.c:                emu->regs[_AX].dword[1] = 0;
src/emu/x64run.c:                Push32(emu, emu->eflags.x64);
src/emu/x64run.c:                Push64(emu, emu->eflags.x64);
src/emu/x64run.c:            emu->eflags.x64 = (((rex.is32bits?Pop32(emu):Pop64(emu)) & 0x3F7FD7)/* & (0xffff-40)*/ ) | 0x2; // mask off res2 and res3 and on res1
src/emu/x64run.c:                if(emu->quit) goto fini;
src/emu/x64run.c:            tmp8u = emu->regs[_AX].byte[1];
src/emu/x64run.c:            R_AH = (uint8_t)emu->eflags.x64;
src/emu/x64run.c:                emu->regs[(opcode&7)+(rex.b<<3)].byte[0] = F8;
src/emu/x64run.c:                emu->regs[opcode&3].byte[0] = F8;
src/emu/x64run.c:                emu->regs[(opcode&7)+(rex.b<<3)].byte[0] = F8;
src/emu/x64run.c:                emu->regs[opcode&3].byte[1] = F8;
src/emu/x64run.c:                emu->regs[(opcode&7)+(rex.b<<3)].q[0] = F64;
src/emu/x64run.c:                emu->regs[(opcode&7)+(rex.b<<3)].q[0] = F32;
src/emu/x64run.c:            if(emu->quit) goto fini;    // R_RIP is up to date when returning from x64Int3
src/emu/x64run.c:                emu->quit = 1;
src/emu/x64run.c:            emu->segs[_CS] = (rex.is32bits?Pop32(emu):Pop64(emu))&0xffff;
src/emu/x64run.c:            emu->segs_serial[_CS] = 0;
src/emu/x64run.c:            emu->eflags.x64 = (((rex.is32bits?Pop32(emu):Pop64(emu)) & 0x3F7FD7)/* & (0xffff-40)*/ ) | 0x2; // mask off res2 and res3 and on res1
src/emu/x64run.c:            emu->segs[_SS] = (rex.is32bits?Pop32(emu):Pop64(emu))&0xffff;
src/emu/x64run.c:            emu->segs_serial[_SS] = 0;
src/emu/x64run.c:            is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:            if(emu->quit) {
src/emu/x64run.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64run.c:                        emu->regs[_DX].dword[1] = 0;
src/emu/x64run.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64run.c:                        emu->regs[_DX].dword[1] = 0;
src/emu/x64run.c:                        //emu->regs[_AX].dword[1] = 0;  // already put high regs to 0
src/emu/x64run.c:                        //emu->regs[_DX].dword[1] = 0;
src/emu/x64run.c:                        //emu->regs[_AX].dword[1] = 0;
src/emu/x64run.c:                        //emu->regs[_DX].dword[1] = 0;
src/emu/x64run.c:                        emu->quit=1;
src/emu/x64run.c:                        emu->error |= ERR_ILLEGAL;
src/emu/x64run.c:                        is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:                        emu->quit=1;
src/emu/x64run.c:                        emu->error |= ERR_ILLEGAL;
src/emu/x64run.c:                        is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run.c:                    emu->quit=1;
src/emu/x64run.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64run.c://if(emu->segs[_CS]!=0x33 && emu->segs[_CS]!=0x23) printf_log(LOG_NONE, "Warning, CS is not default value: 0x%x\n", emu->segs[_CS]);
src/emu/x64run.c:    //printf_log(LOG_DEBUG, "End of X86 run (%p), RIP=%p, Stack=%p, unimp=%d, emu->fork=%d, emu->uc_link=%p, emu->quit=%d\n", emu, (void*)R_RIP, (void*)R_RSP, unimp, emu->fork, emu->uc_link, emu->quit);
src/emu/x64run.c:        emu->quit = 1;
src/emu/x64run.c:    if(emu->fork) {
src/emu/x64run.c:        int forktype = emu->fork;
src/emu/x64run.c:        emu->quit = 0;
src/emu/x64run.c:        emu->fork = 0;
src/emu/x64run.c:    else if(emu->uc_link) {
src/emu/x64run.c:        emu->quit = 0;
src/emu/x64run.c:        my_setcontext(emu, emu->uc_link);
src/emu/x64run0f.c:                    switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64run0f.c:            emu->top = 0;
src/emu/x64run0f.c:            emu->fpu_stack = 0;
src/emu/x64run0f.c:                    emu->mxcsr.x32 = ED->dword[0];
src/emu/x64run0f.c:                    ED->dword[0] = emu->mxcsr.x32;
src/emu/x64run0f.c:                emu->regs[tmp8u].q[0] = __builtin_bswap64(emu->regs[tmp8u].q[0]);
src/emu/x64run0f.c:                emu->regs[tmp8u].q[0] = __builtin_bswap32(emu->regs[tmp8u].dword[0]);
src/emu/x64run64.c:                emu->regs[(nextop&7)+(rex.b<<3)].q[0] = Pop64(emu);
src/emu/x64run64.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64run64.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64run64.c:                        //emu->regs[_AX].dword[1] = 0;  // already put high regs to 0
src/emu/x64run64.c:                        //emu->regs[_DX].dword[1] = 0;
src/emu/x64run64.c:                        //emu->regs[_AX].dword[1] = 0;
src/emu/x64run64.c:                        //emu->regs[_DX].dword[1] = 0;
src/emu/x64run64.c:                        emu->quit=1;
src/emu/x64run64.c:                        emu->error |= ERR_ILLEGAL;
src/emu/x64run64.c:                        emu->quit=1;
src/emu/x64run64.c:                        emu->error |= ERR_ILLEGAL;
src/emu/x64run64.c:                    emu->quit=1;
src/emu/x64run64.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64run66.c:        emu->regs[tmp8u].word[0] = inc16(emu, emu->regs[tmp8u].word[0]);
src/emu/x64run66.c:        emu->regs[tmp8u].word[0] = dec16(emu, emu->regs[tmp8u].word[0]);
src/emu/x64run66.c:            EW->q[0] = emu->segs[((nextop&0x38)>>3)];
src/emu/x64run66.c:            EW->word[0] = emu->segs[((nextop&0x38)>>3)];
src/emu/x64run66.c:                    R_RAX = emu->regs[tmp8u].q[0];
src/emu/x64run66.c:                    emu->regs[tmp8u].q[0] = tmp64u;
src/emu/x64run66.c:                    R_AX = emu->regs[tmp8u].word[0];
src/emu/x64run66.c:                    emu->regs[tmp8u].word[0] = tmp16u;
src/emu/x64run66.c:        emu->regs[_AX].sword[0] = emu->regs[_AX].sbyte[0];
src/emu/x64run66.c:        Push16(emu, (uint16_t)emu->eflags.x64);
src/emu/x64run66.c:        emu->eflags.x64 &=0xffff0000;
src/emu/x64run66.c:        emu->eflags.x64 |= (Pop16(emu) & 0x3F7FD7) | 0x2;
src/emu/x64run66.c:            emu->regs[(opcode&7)+(rex.b<<3)].q[0] = F64;
src/emu/x64run66.c:            emu->regs[(opcode&7)+(rex.b<<3)].word[0] = F16;
src/emu/x64run66.c:                    emu->quit=1;
src/emu/x64run66.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64run660f.c:        switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64run660f.c:                    if(emu->xmm[0].ub[i]&0x80)
src/emu/x64run660f.c:                    if(emu->xmm[0].ud[i]&0x80000000)
src/emu/x64run660f.c:                    if(emu->xmm[0].q[i]&0x8000000000000000LL)
src/emu/x64run660f.c:                    tmp8u = emu->mxcsr.f.MXCSR_RC;
src/emu/x64run660f.c:                    tmp8u = emu->mxcsr.f.MXCSR_RC;
src/emu/x64run660f.c:                    tmp8u = emu->mxcsr.f.MXCSR_RC;
src/emu/x64run660f.c:                    tmp8u = emu->mxcsr.f.MXCSR_RC;
src/emu/x64run660f.c:                switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64run660f.c:            emu->regs[tmp8u].q[0] = __builtin_bswap64(emu->regs[tmp8u].q[0]);
src/emu/x64run660f.c:            emu->regs[tmp8u].word[0] = __builtin_bswap16(emu->regs[tmp8u].word[0]);
src/emu/x64run66f0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64run66f0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64run66f0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64run66f0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64run66f0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64run66f0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64run66f0.c:            pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64run66f0.c:                    emu->quit=1;
src/emu/x64run66f0.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64run67.c:                    emu->regs[_AX].dword[1] = 0;
src/emu/x64run67.c:                    emu->regs[_DX].dword[1] = 0;
src/emu/x64run67.c:                    emu->regs[_AX].dword[1] = 0;
src/emu/x64run67.c:                    emu->regs[_DX].dword[1] = 0;
src/emu/x64run67.c:                    //emu->regs[_AX].dword[1] = 0;
src/emu/x64run67.c:                    //emu->regs[_DX].dword[1] = 0;
src/emu/x64run67.c:                    //emu->regs[_AX].dword[1] = 0;
src/emu/x64run67.c:                    //emu->regs[_DX].dword[1] = 0;
src/emu/x64run_private.c:#define PARITY(x)   (((emu->x64emu_parity_tab[(x) / 32] >> ((x) % 32)) & 1) == 0)
src/emu/x64run_private.c:        if(emu->error)  // any error, don't bother with more
src/emu/x64run_private.c:        emu->quit = 0;
src/emu/x64run_private.c:    if(!emu->quit) {
src/emu/x64run_private.c:        emu->quit = 1;  // finished!
src/emu/x64run_private.c:    switch(emu->df) {
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x100, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u8 & emu->op2.u8) | ((~emu->res.u8) & (emu->op1.u8 | emu->op2.u8));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x10000, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u32 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u16 & emu->op2.u16) | ((~emu->res.u16) & (emu->op1.u16 | emu->op2.u16));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x100000000LL, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u64 & 0xffffffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u32 & emu->op2.u32) | ((~emu->res.u32) & (emu->op1.u32 | emu->op2.u32));
src/emu/x64run_private.c:            lo = (emu->op2.u32 & 0xFFFF) + (emu->op1.u32 & 0xFFFF);
src/emu/x64run_private.c:            hi = (lo >> 16) + (emu->op2.u32 >> 16) + (emu->op1.u32 >> 16);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u32 & emu->op2.u32) | ((~emu->res.u32) & (emu->op1.u32 | emu->op2.u32));
src/emu/x64run_private.c:            lo = (emu->op2.u64 & 0xFFFFFFFF) + (emu->op1.u64 & 0xFFFFFFFF);
src/emu/x64run_private.c:            hi = (lo >> 32) + (emu->op2.u64 >> 32) + (emu->op1.u64 >> 32);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u64 & emu->op2.u64) | ((~emu->res.u64) & (emu->op1.u64 | emu->op2.u64));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u8 & (~emu->op1.u8 | 1)) | (~emu->op1.u8 & 1);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u16 & (~emu->op1.u16 | 1)) | (~emu->op1.u16 & 1);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u32 & (~emu->op1.u32 | 1)) | (~emu->op1.u32 & 1);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u64 & (~emu->op1.u64 | 1)) | (~emu->op1.u64 & 1);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = ((1 & emu->op1.u8) | (~emu->res.u8)) & (1 | emu->op1.u8);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (1 & emu->op1.u16) | ((~emu->res.u16) & (1 | emu->op1.u16));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (1 & emu->op1.u32) | ((~emu->res.u32) & (1 | emu->op1.u32));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (1 & emu->op1.u64) | ((~emu->res.u64) & (1 | emu->op1.u64));
src/emu/x64run_private.c:            lo = emu->res.u16 & 0xff;
src/emu/x64run_private.c:            hi = (emu->res.u16>>8)&0xff;
src/emu/x64run_private.c:            lo = (uint16_t)emu->res.u32;
src/emu/x64run_private.c:            hi = (uint16_t)(emu->res.u32 >> 16);
src/emu/x64run_private.c:            if (((emu->res.u32 & 0x80000000) == 0 && emu->op1.u32 == 0x00) ||
src/emu/x64run_private.c:                ((emu->res.u32 & 0x80000000) != 0 && emu->op1.u32 == 0xFFFFFFFF)) {
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            if (((emu->res.u64 & 0x8000000000000000LL) == 0 && emu->op1.u64 == 0x00) ||
src/emu/x64run_private.c:                ((emu->res.u64 & 0x8000000000000000LL) != 0 && emu->op1.u64 == 0xFFFFFFFFFFFFFFFFLL)) {
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            lo = emu->res.u16 & 0xff;
src/emu/x64run_private.c:            hi = (emu->res.u16>>8)&0xff;
src/emu/x64run_private.c:            lo = (uint16_t)emu->res.u32;
src/emu/x64run_private.c:            hi = (uint16_t)(emu->res.u32 >> 16);
src/emu/x64run_private.c:            if (emu->op1.u32 == 0) {
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            if (emu->op1.u64 == 0) {
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->op1.u8 != 0, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = emu->res.u8 | emu->op1.u8;
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->op1.u16 != 0, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = emu->res.u16 | emu->op1.u16;
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->op1.u32 != 0, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = emu->res.u32 | emu->op1.u32;
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->op1.u64 != 0, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = emu->res.u64 | emu->op1.u64;
src/emu/x64run_private.c:            if (emu->op2.u8 < 8) {
src/emu/x64run_private.c:                cnt = emu->op2.u8 % 8;
src/emu/x64run_private.c:                    cc = emu->op1.u8 & (1 << (8 - cnt));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((((emu->res.u8 & 0x80) == 0x80) ^(ACCESS_FLAG(F_CF) != 0)), F_OF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->op1.u8 << (emu->op2.u8-1)) & 0x80, F_CF);
src/emu/x64run_private.c:            if (emu->op2.u16 < 16) {
src/emu/x64run_private.c:                cnt = emu->op2.u16 % 16;
src/emu/x64run_private.c:                    cc = emu->op1.u16 & (1 << (16 - cnt));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(((!!(emu->res.u16 & 0x8000)) ^(ACCESS_FLAG(F_CF) != 0)), F_OF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->op1.u16 << (emu->op2.u16-1)) & 0x8000, F_CF);
src/emu/x64run_private.c:            if (emu->op2.u32 < 32) {
src/emu/x64run_private.c:                cnt = emu->op2.u32 % 32;
src/emu/x64run_private.c:                    cc = emu->op1.u32 & (1 << (32 - cnt));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(((!!(emu->res.u32 & 0x80000000)) ^
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->op1.u32 << (emu->op2.u32-1)) & 0x80000000, F_CF);
src/emu/x64run_private.c:            if (emu->op2.u64 > 0) {
src/emu/x64run_private.c:                cc = emu->op1.u64 & (1LL << (64 - emu->op2.u64));
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            if (emu->op2.u64 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(((!!(emu->res.u64 & 0x8000000000000000LL)) ^
src/emu/x64run_private.c:            if (emu->op2.u8 < 8) {
src/emu/x64run_private.c:                if(emu->op2.u8) {
src/emu/x64run_private.c:                    cc = emu->op1.u8 & (1 << (emu->op2.u8 - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:                if (emu->op1.u8&0x80) {
src/emu/x64run_private.c:            if (emu->op2.u16 < 16) {
src/emu/x64run_private.c:                if(emu->op2.u16) {
src/emu/x64run_private.c:                    cc = emu->op1.u16 & (1 << (emu->op2.u16 - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:                if (emu->op1.u16&0x8000) {
src/emu/x64run_private.c:            if (emu->op2.u32 < 32) {
src/emu/x64run_private.c:                if(emu->op2.u32) {
src/emu/x64run_private.c:                    cc = emu->op1.u32 & (1 << (emu->op2.u32 - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u32 & 0xffffffff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:                if (emu->op1.u32&0x80000000) {
src/emu/x64run_private.c:            if(emu->op2.u64) {
src/emu/x64run_private.c:                cc = emu->op1.u64 & (1LL << (emu->op2.u64 - 1));
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(emu->res.u64 == 0, F_ZF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            if (emu->op2.u8 < 8) {
src/emu/x64run_private.c:                cnt = emu->op2.u8 % 8;
src/emu/x64run_private.c:                    cc = emu->op1.u8 & (1 << (cnt - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(XOR2(emu->res.u8 >> 6), F_OF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->op1.u8 >> (emu->op2.u8-1)) & 0x1, F_CF);
src/emu/x64run_private.c:            if (emu->op2.u16 < 16) {
src/emu/x64run_private.c:                cnt = emu->op2.u16 % 16;
src/emu/x64run_private.c:                    cc = emu->op1.u16 & (1 << (cnt - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(XOR2(emu->res.u16 >> 14), F_OF);
src/emu/x64run_private.c:            if (emu->op2.u32 < 32) {
src/emu/x64run_private.c:                cnt = emu->op2.u32 % 32;
src/emu/x64run_private.c:                    cc = emu->op1.u32 & (1 << (cnt - 1));
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG((emu->res.u32 & 0xffffffff) == 0, F_ZF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:                    CONDITIONAL_SET_FLAG(XOR2(emu->res.u32 >> 30), F_OF);
src/emu/x64run_private.c:            cnt = emu->op2.u64;
src/emu/x64run_private.c:                cc = emu->op1.u64 & (1LL << (cnt - 1));
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(XOR2(emu->res.u64 >> 62), F_OF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u8 & (~emu->op1.u8 | emu->op2.u8)) | (~emu->op1.u8 & emu->op2.u8);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u16 & (~emu->op1.u16 | emu->op2.u16)) | (~emu->op1.u16 & emu->op2.u16);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u32 & (~emu->op1.u32 | emu->op2.u32)) | (~emu->op1.u32 & emu->op2.u32);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u64 & (~emu->op1.u64 | emu->op2.u64)) | (~emu->op1.u64 & emu->op2.u64);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u8 & (~emu->op1.u8 | emu->op2.u8)) | (~emu->op1.u8 & emu->op2.u8);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u16 & (~emu->op1.u16 | emu->op2.u16)) | (~emu->op1.u16 & emu->op2.u16);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:        	bc = (emu->res.u32 & (~emu->op1.u32 | emu->op2.u32)) | (~emu->op1.u32 & emu->op2.u32);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:        	bc = (emu->res.u64 & (~emu->op1.u64 | emu->op2.u64)) | (~emu->op1.u64 & emu->op2.u64);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u8 == 0, F_ZF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u32 == 0, F_ZF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u64 == 0, F_ZF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x100, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u8 & emu->op2.u8) | ((~emu->res.u8) & (emu->op1.u8 | emu->op2.u8));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x10000, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u16 & emu->op2.u16) | ((~emu->res.u16) & (emu->op1.u16 | emu->op2.u16));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x100000000L, F_CF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u32 & 0xffffffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op1.u32 & emu->op2.u32) | ((~emu->res.u32) & (emu->op1.u32 | emu->op2.u32));
src/emu/x64run_private.c:            if(emu->res.u32 == (emu->op1.u32+emu->op2.u32)) {
src/emu/x64run_private.c:                lo = (emu->op1.u32 & 0xFFFF) + (emu->op2.u32 & 0xFFFF);
src/emu/x64run_private.c:                lo = 1 + (emu->op1.u32 & 0xFFFF) + (emu->op2.u32 & 0xFFFF);
src/emu/x64run_private.c:            hi = (lo >> 16) + (emu->op1.u32 >> 16) + (emu->op2.u32 >> 16);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op2.u32 & emu->op1.u32) | ((~emu->res.u32) & (emu->op2.u32 | emu->op1.u32));
src/emu/x64run_private.c:            if(emu->res.u64 == (emu->op1.u64+emu->op2.u64)) {
src/emu/x64run_private.c:                lo = (emu->op1.u64 & 0xFFFFFFFF) + (emu->op2.u64 & 0xFFFFFFFF);
src/emu/x64run_private.c:                lo = 1 + (emu->op1.u64 & 0xFFFFFFFF) + (emu->op2.u64 & 0xFFFFFFFF);
src/emu/x64run_private.c:            hi = (lo >> 32) + (emu->op1.u64 >> 32) + (emu->op2.u64 >> 32);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            cc = (emu->op2.u64 & emu->op1.u64) | ((~emu->res.u64) & (emu->op2.u64 | emu->op1.u64));
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & 0x80, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u8 & 0xff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u8 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u8 & (~emu->op1.u8 | emu->op2.u8)) | (~emu->op1.u8 & emu->op2.u8);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & 0x8000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG((emu->res.u16 & 0xffff) == 0, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u16 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u16 & (~emu->op1.u16 | emu->op2.u16)) | (~emu->op1.u16 & emu->op2.u16);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & 0x80000000, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u32, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u32 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u32 & (~emu->op1.u32 | emu->op2.u32)) | (~emu->op1.u32 & emu->op2.u32);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & 0x8000000000000000LL, F_SF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(!emu->res.u64, F_ZF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(PARITY(emu->res.u64 & 0xff), F_PF);
src/emu/x64run_private.c:            bc = (emu->res.u64 & (~emu->op1.u64 | emu->op2.u64)) | (~emu->op1.u64 & emu->op2.u64);
src/emu/x64run_private.c:            if(emu->op2.u8 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->res.u8 + (emu->res.u8 >> 7)) & 1, F_OF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u16 & 0x1, F_CF);
src/emu/x64run_private.c:            if(emu->op2.u16 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->res.u16 + (emu->res.u16 >> 15)) & 1, F_OF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u16 & 0x1, F_CF);
src/emu/x64run_private.c:            if(emu->op2.u32 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->res.u32 + (emu->res.u32 >> 31)) & 1, F_OF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u32 & 0x1, F_CF);
src/emu/x64run_private.c:            if(emu->op2.u64 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG((emu->res.u64 + (emu->res.u64 >> 63)) & 1, F_OF);
src/emu/x64run_private.c:        	CONDITIONAL_SET_FLAG(emu->res.u64 & 0x1, F_CF);
src/emu/x64run_private.c:            if(emu->op2.u8 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(XOR2(emu->res.u8 >> 6), F_OF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u8 & (1 << 7), F_CF);
src/emu/x64run_private.c:            if(emu->op2.u16 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(XOR2(emu->res.u16 >> 14), F_OF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u16 & (1 << 15), F_CF);
src/emu/x64run_private.c:            if(emu->op2.u32 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(XOR2(emu->res.u32 >> 30), F_OF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u32 & (1 << 31), F_CF);
src/emu/x64run_private.c:            if(emu->op2.u64 == 1) {
src/emu/x64run_private.c:                CONDITIONAL_SET_FLAG(XOR2(emu->res.u64 >> 62), F_OF);
src/emu/x64run_private.c:            CONDITIONAL_SET_FLAG(emu->res.u64 & (1L << 63), F_CF);
src/emu/x64run_private.c:                deferred_flags_t df = emu->df - (d_dec8i - d_dec8);
src/emu/x64run_private.c:                if(emu->df_sav!=d_none) {
src/emu/x64run_private.c:                    multiuint_t op1 = emu->op1;
src/emu/x64run_private.c:                    multiuint_t res = emu->res;
src/emu/x64run_private.c:                    emu->df = emu->df_sav;
src/emu/x64run_private.c:                    emu->op1 = emu->op1_sav;
src/emu/x64run_private.c:                    emu->res = emu->res_sav;
src/emu/x64run_private.c:                    emu->df_sav = d_none;
src/emu/x64run_private.c:                    emu->op1 = op1;
src/emu/x64run_private.c:                    emu->res = res;
src/emu/x64run_private.c:                emu->df = df;
src/emu/x64run_private.c:    if(emu->segs_serial[seg] != emu->context->sel_serial) {
src/emu/x64run_private.c:        emu->segs_offs[seg] = (uintptr_t)GetSegmentBase(emu->segs[seg]);
src/emu/x64run_private.c:        emu->segs_serial[seg] = emu->context->sel_serial;
src/emu/x64run_private.c:    return emu->segs_offs[seg];
src/emu/x64run_private.c:    int is32bits = (emu->segs[_CS]==0x23);
src/emu/x64run_private.c:            base += ((sib&0x7)==5)?((uint32_t)F32S(addr)):(emu->regs[(sib&0x7)].dword[0]); // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)]->sdword[0] << (sib>>6));
src/emu/x64run_private.c:        return (reg64_t*)(uintptr_t)(base + emu->regs[m].dword[0]);
src/emu/x64run_private.c:            base += emu->regs[(sib&0x7)].dword[0]; // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)]->sdword[0] << (sib>>6));
src/emu/x64run_private.c:            base += emu->regs[(m&0x7)].dword[0];
src/emu/x64run_private.c:            uintptr_t base = ((sib&0x7)==5)?((uint64_t)(int64_t)F32S(addr)):(emu->regs[(sib&0x7)+(rex.b<<3)].q[0]); // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sq[0] << (sib>>6));
src/emu/x64run_private.c:        return (reg64_t*)(emu->regs[m+(rex.b<<3)].q[0]);
src/emu/x64run_private.c:            base = emu->regs[(sib&0x7)+(rex.b<<3)].q[0]; // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sq[0] << (sib>>6));
src/emu/x64run_private.c:            base = emu->regs[(m&0x7)+(rex.b<<3)].q[0];
src/emu/x64run_private.c:            base += ((sib&0x7)==5)?((uint64_t)(int64_t)F32S(addr)):(emu->regs[(sib&0x7)+(rex.b<<3)].q[0]); // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sq[0] << (sib>>6));
src/emu/x64run_private.c:        return (reg64_t*)(base + emu->regs[m+(rex.b<<3)].q[0]);
src/emu/x64run_private.c:            base += emu->regs[(sib&0x7)+(rex.b<<3)].q[0]; // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sq[0] << (sib>>6));
src/emu/x64run_private.c:            base += emu->regs[(m&0x7)+(rex.b<<3)].q[0];
src/emu/x64run_private.c:            base += ((sib&0x7)==5)?((uint64_t)(int64_t)F32S(addr)):(emu->regs[(sib&0x7)+(rex.b<<3)].dword[0]); // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sdword[0] << (sib>>6));
src/emu/x64run_private.c:        return (reg64_t*)(uintptr_t)(base + emu->regs[m+(rex.b<<3)].dword[0]);
src/emu/x64run_private.c:            base += emu->regs[(sib&0x7)+(rex.b<<3)].dword[0]; // base
src/emu/x64run_private.c:            base += (emu->sbiidx[((sib>>3)&7)+(rex.x<<3)]->sdword[0] << (sib>>6));
src/emu/x64run_private.c:            base += emu->regs[(m&0x7)+(rex.b<<3)].dword[0];
src/emu/x64run_private.c:            return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:            return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&test->emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:            return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:            return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&test->emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return (uintptr_t)&emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return &emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:            return &test->emu->regs[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:            return (reg64_t *)(((char*)(&test->emu->regs[(m&0x03)]))+lowhigh);  //?
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)];
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)];
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)];
src/emu/x64run_private.c:         return &emu->regs[(m&0x07)];
src/emu/x64run_private.c:         return &emu->mmx[m&0x07];
src/emu/x64run_private.c:         return &test->emu->mmx[m&0x07];
src/emu/x64run_private.c:         return &emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &test->emu->xmm[(m&0x07)+(rex.b<<3)];
src/emu/x64run_private.c:         return &emu->mmx[(m&0x07)];
src/emu/x64run_private.c:         return &test->emu->mmx[(m&0x07)];
src/emu/x64run_private.c:    return &emu->regs[((v&0x38)>>3)+(rex.r<<3)];
src/emu/x64run_private.c:        return &emu->regs[(m&7)+(rex.r<<3)];
src/emu/x64run_private.c:        return (reg64_t*)&emu->regs[m&3].byte[m>>2];
src/emu/x64run_private.c:    return &emu->mmx[m&7];
src/emu/x64run_private.c:    return &emu->xmm[(m&7)+(rex.r<<3)];
src/emu/x64run_private.h:#define CHECK_FLAGS(emu) if(emu->df) UpdateFlags(emu)
src/emu/x64run_private.h:#define RESET_FLAGS(emu) emu->df = d_none
src/emu/x64rund9.c:            emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:                emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:                emu->sw.f.F87_C1 = (ll&1)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C3 = (ll&2)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C0 = (ll&4)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C2 = 1;
src/emu/x64rund9.c:                emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:                emu->sw.f.F87_C1 = (ll&1)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C3 = (ll&2)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C0 = (ll&4)?1:0;
src/emu/x64rund9.c:                emu->sw.f.F87_C2 = 1;
src/emu/x64rund9.c:            emu->top=(emu->top-1)&7;    // this will probably break a few things
src/emu/x64rund9.c:            emu->top=(emu->top+1)&7;    // this will probably break a few things
src/emu/x64rund9.c:            emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:            emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:            emu->sw.f.F87_C2 = 0;
src/emu/x64rund9.c:                emu->cw.x16 = EW->word[0];
src/emu/x64rund9.c:                EW->word[0] = emu->cw.x16;
src/emu/x64rundb.c:        emu->sw.f.F87_PE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_UE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_OE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_ZE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_DE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_IE = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_ES = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_SF = 0;
src/emu/x64rundb.c:        emu->sw.f.F87_B = 0;
src/emu/x64rundd.c:                emu->sw.f.F87_TOP = emu->top&7;
src/emu/x64rundd.c:                *(uint16_t*)ED = emu->sw.x16;
src/emu/x64rundf.c:        emu->sw.f.F87_TOP = emu->top&7;
src/emu/x64rundf.c:        R_AX = emu->sw.x16;
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);          \
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);        \
src/emu/x64runf0.c:                pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                        emu->regs[_AX].dword[1] = 0;
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                            pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                            pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                pthread_mutex_lock(&emu->context->mutex_lock); // XCHG always LOCK (but when accessing memory only)
src/emu/x64runf0.c:                pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:            pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    emu->quit=1;
src/emu/x64runf0.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_lock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    pthread_mutex_unlock(&emu->context->mutex_lock);
src/emu/x64runf0.c:                    emu->quit=1;
src/emu/x64runf0.c:                    emu->error |= ERR_ILLEGAL;
src/emu/x64runf20f.c:                switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64runf20f.c:                switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64runf20f.c:        switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64runf30f.c:                switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64runf30f.c:                switch(emu->mxcsr.f.MXCSR_RC) {
src/emu/x64syscall.c:                   emu->quit = 1;
src/emu/x64syscall.c:                        if((R_RSP>=(uintptr_t)emu->init_stack) && (R_RSP<=((uintptr_t)emu->init_stack+emu->size_stack)))
src/emu/x64syscall.c:                        stack_size = (currstack && emu->size_stack)?emu->size_stack:(1024*1024);
src/emu/x64syscall.c:                            memcpy(stack_base, emu->init_stack, stack_size);
src/emu/x64syscall.c:                            int size_to_copy = (uintptr_t)emu->init_stack + emu->size_stack - (R_RSP);
src/emu/x64syscall.c:                    x64emu_t * newemu = NewX64Emu(emu->context, R_RIP, (uintptr_t)stack_base, stack_size, (R_RSI)?0:1);
src/emu/x64syscall.c:            emu->quit = 1;
src/emu/x64syscall.c:            emu->error |= ERR_UNIMPL;
src/emu/x64syscall.c:                   emu->quit = 1;
src/emu/x64syscall.c:                    if((R_RSP>=(uintptr_t)emu->init_stack) && (R_RSP<=((uintptr_t)emu->init_stack+emu->size_stack)))
src/emu/x64syscall.c:                    stack_size = (currstack)?emu->size_stack:(1024*1024);
src/emu/x64syscall.c:                        memcpy(stack_base, emu->init_stack, stack_size);
src/emu/x64syscall.c:                        int size_to_copy = (uintptr_t)emu->init_stack + emu->size_stack - (R_RSP);
src/emu/x64syscall.c:                x64emu_t * newemu = NewX64Emu(emu->context, R_RIP, (uintptr_t)stack_base, stack_size, (R_RDX)?0:1);
src/emu/x64test.c:    if(memcmp(ref->regs, emu->regs, sizeof(emu->regs))) {
src/emu/x64test.c:            if(ref->regs[i].q[0]!=emu->regs[i].q[0]) {
src/emu/x64test.c:                printf_log(LOG_NONE, "%s: %016zx | %016zx\n", regname[i], ref->regs[i].q[0], emu->regs[i].q[0]);
src/emu/x64test.c:    if(ip!=emu->ip.q[0]) {
src/emu/x64test.c:        printf_log(LOG_NONE, "RIP: %016zx | %016zx\n", ip, emu->ip.q[0]);
src/emu/x64test.c:	//memcpy(&ref->eflags, &emu->eflags, sizeof(emu->eflags));
src/emu/x64test.c:    if(memcmp(ref->segs, emu->segs, sizeof(emu->segs))) {
src/emu/x64test.c:            if(ref->segs[i]!=emu->segs[i]) {
src/emu/x64test.c:                printf_log(LOG_NONE, "%s: %04x | %04x\n", segname[i], ref->segs[i], emu->segs[i]);
src/emu/x64test.c:    if(ref->top != emu->top) {
src/emu/x64test.c:        printf_log(LOG_NONE, "X87 TOP: %d | %d\n", ref->top, emu->top);
src/emu/x64test.c:    if(ref->fpu_stack != emu->fpu_stack) {
src/emu/x64test.c:        printf_log(LOG_NONE, "X87 STACK: %d | %d\n", ref->fpu_stack, emu->fpu_stack);
src/emu/x64test.c:	if(ref->fpu_stack && memcmp(ref->x87, emu->x87, sizeof(emu->x87))) {
src/emu/x64test.c:            if(ref->x87[(ref->top+i)&7].d != emu->x87[(emu->top+i)&7].d) {
src/emu/x64test.c:                printf_log(LOG_NONE, "ST%d: %g | %g\n", i, ref->x87[(ref->top+i)&7].d, emu->x87[(emu->top+i)&7].d);
src/emu/x64test.c:    //memcpy(ref->fpu_ld, emu->fpu_ld, sizeof(emu->fpu_ld));
src/emu/x64test.c:    //memcpy(ref->fpu_ll, emu->fpu_ll, sizeof(emu->fpu_ll));
src/emu/x64test.c:	/*if(ref->p_regs != emu->p_regs) {
src/emu/x64test.c:        printf_log(LOG_NONE, "X87 PREG: %x | %x\n", ref->p_regs, emu->p_regs);
src/emu/x64test.c:	if(ref->cw.x16 != emu->cw.x16) {
src/emu/x64test.c:        printf_log(LOG_NONE, "X87 CW: %x | %x\n", ref->cw.x16, emu->cw.x16);
src/emu/x64test.c:	if(ref->sw.x16 != emu->sw.x16) {
src/emu/x64test.c:        printf_log(LOG_NONE, "X87 SW: %x | %x\n", ref->sw.x16, emu->sw.x16);
src/emu/x64test.c:	if(memcmp(ref->mmx, emu->mmx, sizeof(emu->mmx))) {
src/emu/x64test.c:            if(ref->mmx[i].q!=emu->mmx[i].q) {
src/emu/x64test.c:                printf_log(LOG_NONE, "EMM[%d]: %016x | %016x\n", i, ref->mmx[i].q, emu->mmx[i].q);
src/emu/x64test.c:    if(ref->mxcsr.x32 != emu->mxcsr.x32) {
src/emu/x64test.c:        printf_log(LOG_NONE, "MXCSR: %x | %x\n", ref->mxcsr.x32, emu->mxcsr.x32);
src/emu/x64test.c:    if(memcmp(ref->xmm, emu->xmm, sizeof(emu->xmm))) {
src/emu/x64test.c:            if(ref->xmm[i].q[0]!=emu->xmm[i].q[0] || ref->xmm[i].q[1]!=emu->xmm[i].q[1] ) {
src/emu/x64test.c:                printf_log(LOG_NONE, "XMM[%02d]: %016zx-%016zx | %016zx-%016zx\n", i, ref->xmm[i].q[1], ref->xmm[i].q[0], emu->xmm[i].q[1], emu->xmm[i].q[0]);
src/emu/x64test.c:        uintptr_t prev_ip = test->emu->ip.q[0];
src/emu/x64tls.c:    printf_log(LOG_DEBUG, "%04d| arch_prctl(0x%x, %p) (RSP=%p, FS=0x%x, GS=0x%x)\n", GetTID(), code, addr,(void*)R_RSP, emu->segs[_FS], emu->segs[_GS]);
src/emu/x64tls.c:            *(void**)addr = GetSegmentBase(emu->segs[_GS]);
src/emu/x64tls.c:            *(void**)addr = GetSegmentBase(emu->segs[_FS]);
src/emu/x64tls.c:               printf_log(LOG_DEBUG, "Changing segment selector from 0x%x to 0x%x\n", emu->segs[seg], (idx<<3) +3);
src/emu/x64tls.c:               emu->segs[seg]=(idx<<3) +3;
src/emu/x64tls.c:            if(emu->segs[seg]==0) {
src/emu/x64tls.c:            idx = emu->segs[seg] >> 3;
src/emu/x64tls.c:            emu->segs_serial[seg] = 0;
src/emu/x86syscall.c:                   emu->quit = 1;
src/emu/x86syscall.c:            emu->quit = 1;
src/emu/x86syscall.c:            emu->exit = 1;
src/emu/x87emu_private.c:    emu->p_regs[(emu->top+i)&7].tag = 0b11;    // empty
src/emu/x87emu_private.c:        if(emu->p_regs[j].tag != 0b11)
src/emu/x87emu_private.c:    emu->fpu_stack = 0;
src/emu/x87emu_private.c:    memset(emu->x87, 0, sizeof(emu->x87));
src/emu/x87emu_private.c:    memset(emu->fpu_ld, 0, sizeof(emu->fpu_ld));
src/emu/x87emu_private.c:    emu->cw.x16 = 0x37F;
src/emu/x87emu_private.c:    emu->sw.x16 = 0x0000;
src/emu/x87emu_private.c:    emu->top = 0;
src/emu/x87emu_private.c:    emu->fpu_stack = 0;
src/emu/x87emu_private.c:        emu->p_regs[i].tag = 0b11;  // STx is empty
src/emu/x87emu_private.c:    emu->cw.x16 = *(uint16_t*)p;
src/emu/x87emu_private.c:    emu->sw.x16 = *(uint16_t*)p;
src/emu/x87emu_private.c:    emu->top = emu->sw.f.F87_TOP;
src/emu/x87emu_private.c:        emu->p_regs[i].tag = (tags>>(i*2))&0b11;
src/emu/x87emu_private.c:    emu->sw.f.F87_TOP = emu->top&7;
src/emu/x87emu_private.c:    *(uint16_t*)p = emu->cw.x16;
src/emu/x87emu_private.c:    *(uint16_t*)p = emu->sw.x16;
src/emu/x87emu_private.c:        tags |= (emu->p_regs[i].tag)<<(i*2);
src/emu/x87emu_private.c:    int top = emu->top&7;
src/emu/x87emu_private.c:        stack = (emu->p_regs[0].tag)?8:0;
src/emu/x87emu_private.c:    emu->sw.f.F87_TOP = top;
src/emu/x87emu_private.c:    p->ControlWord = emu->cw.x16;
src/emu/x87emu_private.c:    p->StatusWord = emu->sw.x16;
src/emu/x87emu_private.c:    p->MxCsr = emu->mxcsr.x32;
src/emu/x87emu_private.c:        tags |= ((emu->p_regs[i].tag)<<(i*2)==0b11)?0:1;
src/emu/x87emu_private.c:        memcpy(&p->FloatRegisters[i].q[0], (i<stack)?&ST(i):&emu->mmx[i], sizeof(mmx87_regs_t));
src/emu/x87emu_private.c:    memcpy(&p->XmmRegisters[0], &emu->xmm[0], sizeof(emu->xmm));
src/emu/x87emu_private.c:    int top = emu->top&7;
src/emu/x87emu_private.c:        stack = (emu->p_regs[0].tag)?8:0;
src/emu/x87emu_private.c:    emu->sw.f.F87_TOP = top;
src/emu/x87emu_private.c:    p->ControlWord = emu->cw.x16;
src/emu/x87emu_private.c:    p->StatusWord = emu->sw.x16;
src/emu/x87emu_private.c:    p->MxCsr = emu->mxcsr.x32;
src/emu/x87emu_private.c:        tags |= ((emu->p_regs[i].tag)<<(i*2)==0b11)?0:1;
src/emu/x87emu_private.c:        memcpy(&p->FloatRegisters[i].q[0], (i<stack)?&ST(i):&emu->mmx[i], sizeof(mmx87_regs_t));
src/emu/x87emu_private.c:    memcpy(&p->XmmRegisters[0], &emu->xmm[0], sizeof(emu->xmm));
src/emu/x87emu_private.c:    emu->cw.x16 = p->ControlWord;
src/emu/x87emu_private.c:    emu->sw.x16 = p->StatusWord;
src/emu/x87emu_private.c:    emu->mxcsr.x32 = p->MxCsr;
src/emu/x87emu_private.c:    emu->top = emu->sw.f.F87_TOP;
src/emu/x87emu_private.c:        emu->p_regs[i].tag = (tags>>(i*2))?0:0b11;
src/emu/x87emu_private.c:    int top = emu->top&7;
src/emu/x87emu_private.c:        stack = (emu->p_regs[0].tag)?8:0;
src/emu/x87emu_private.c:        memcpy((i<stack)?&ST(i):&emu->mmx[i], &p->FloatRegisters[i].q[0], sizeof(mmx87_regs_t));
src/emu/x87emu_private.c:    memcpy(&emu->xmm[0], &p->XmmRegisters[0], sizeof(emu->xmm));
src/emu/x87emu_private.c:    emu->cw.x16 = p->ControlWord;
src/emu/x87emu_private.c:    emu->sw.x16 = p->StatusWord;
src/emu/x87emu_private.c:    emu->mxcsr.x32 = p->MxCsr;
src/emu/x87emu_private.c:    emu->top = emu->sw.f.F87_TOP;
src/emu/x87emu_private.c:        emu->p_regs[i].tag = (tags>>(i*2))?0:0b11;
src/emu/x87emu_private.c:    int top = emu->top&7;
src/emu/x87emu_private.c:        stack = (emu->p_regs[0].tag)?8:0;
src/emu/x87emu_private.c:        memcpy((i<stack)?&ST(i):&emu->mmx[i], &p->FloatRegisters[i].q[0], sizeof(mmx87_regs_t));
src/emu/x87emu_private.c:    memcpy(&emu->xmm[0], &p->XmmRegisters[0], sizeof(emu->xmm));
src/emu/x87emu_private.h:#define ST0 emu->x87[emu->top]
src/emu/x87emu_private.h:#define ST1 emu->x87[(emu->top+1)&7]
src/emu/x87emu_private.h:#define ST(a) emu->x87[(emu->top+(a))&7]
src/emu/x87emu_private.h:#define STld(a)  emu->fpu_ld[(emu->top+(a))&7]
src/emu/x87emu_private.h:#define STll(a)  emu->fpu_ll[(emu->top+(a))&7]
src/emu/x87emu_private.h:    int newtop = (emu->top-1)&7;
src/emu/x87emu_private.h:    /*if(emu->p_regs[newtop].tag!=0b11) {// not empty, overflow!
src/emu/x87emu_private.h:        printf_log(LOG_NONE, "Warning: %p: FPU Stack overflow\n", (void*)emu->old_ip);    // probably better to raise something
src/emu/x87emu_private.h:        //emu->quit = 1;
src/emu/x87emu_private.h:    if(emu->fpu_stack<8)
src/emu/x87emu_private.h:        ++emu->fpu_stack; 
src/emu/x87emu_private.h:    emu->p_regs[newtop].tag = 0;    // full
src/emu/x87emu_private.h:    emu->top = newtop;
src/emu/x87emu_private.h:    int curtop = (emu->top)&7;
src/emu/x87emu_private.h:    /*if(emu->p_regs[(emu->top)&7].tag==0b11) {// underflow
src/emu/x87emu_private.h:        printf_log(LOG_NONE, "Warning: %p: FPU Stack underflow\n", (void*)emu->old_ip);    // probably better to raise something
src/emu/x87emu_private.h:        //emu->quit = 1;
src/emu/x87emu_private.h:    if(emu->fpu_stack>0)
src/emu/x87emu_private.h:        --emu->fpu_stack;
src/emu/x87emu_private.h:    emu->p_regs[curtop].tag = 0b11;    // empty
src/emu/x87emu_private.h:    emu->top = (emu->top+1)&7;
src/emu/x87emu_private.h:    emu->sw.f.F87_C1 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:    emu->sw.f.F87_C1 = 0;
src/emu/x87emu_private.h:    switch(emu->cw.f.C87_RD) {
src/emu/x87emu_private.h:    emu->sw.f.F87_C1 = (ST0.ud[1]&0x80000000)?1:0;
src/emu/x87emu_private.h:    if(!emu->fpu_stack) {
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C2 = 1;
src/emu/x87emu_private.h:    emu->sw.f.F87_C0 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C1 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C3 = 1;
src/emu/x87emu_private.h:        emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:        emu->sw.f.F87_C0 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C3 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C2 = 0;
src/emu/x87emu_private.h:    emu->sw.f.F87_C0 = (ST0.ud[1]&0x80000000)?1:0;
src/include/complext.h:    ret.r = emu->xmm[i].f[0];
src/include/complext.h:    ret.i = emu->xmm[i].f[1];
src/include/complext.h:    ret.r = emu->xmm[i].d[0];
src/include/complext.h:    ret.i = emu->xmm[i+1].d[0];
src/include/complext.h:    emu->xmm[0].f[0]=v.r;
src/include/complext.h:    emu->xmm[0].f[1]=v.i;
src/include/complext.h:    emu->xmm[0].d[0]=v.r; 
src/include/complext.h:    emu->xmm[1].d[0]=v.i;
src/include/myalign.h:    memcpy(&p[6], emu->xmm, 8*16);                  \
src/include/myalign.h:    memcpy(&p[6], emu->xmm, 8*16);                                      \
src/include/myalign.h:#define PREPARE_VALIST CREATE_SYSV_VALIST(emu->scratch)
src/include/regs.h:#define R_RIP emu->ip.q[0]
src/include/regs.h:#define R_RAX emu->regs[_AX].q[0]
src/include/regs.h:#define R_RBX emu->regs[_BX].q[0]
src/include/regs.h:#define R_RCX emu->regs[_CX].q[0]
src/include/regs.h:#define R_RDX emu->regs[_DX].q[0]
src/include/regs.h:#define R_RDI emu->regs[_DI].q[0]
src/include/regs.h:#define R_RSI emu->regs[_SI].q[0]
src/include/regs.h:#define R_RSP emu->regs[_SP].q[0]
src/include/regs.h:#define R_RBP emu->regs[_BP].q[0]
src/include/regs.h:#define R_R8 emu->regs[_R8].q[0]
src/include/regs.h:#define R_R9 emu->regs[_R9].q[0]
src/include/regs.h:#define R_R10 emu->regs[_R10].q[0]
src/include/regs.h:#define R_R11 emu->regs[_R11].q[0]
src/include/regs.h:#define R_R12 emu->regs[_R12].q[0]
src/include/regs.h:#define R_R13 emu->regs[_R13].q[0]
src/include/regs.h:#define R_R14 emu->regs[_R14].q[0]
src/include/regs.h:#define R_R15 emu->regs[_R15].q[0]
src/include/regs.h:#define R_EAX emu->regs[_AX].dword[0]
src/include/regs.h:#define R_EBX emu->regs[_BX].dword[0]
src/include/regs.h:#define R_ECX emu->regs[_CX].dword[0]
src/include/regs.h:#define R_EDX emu->regs[_DX].dword[0]
src/include/regs.h:#define R_EDI emu->regs[_DI].dword[0]
src/include/regs.h:#define R_ESI emu->regs[_SI].dword[0]
src/include/regs.h:#define R_ESP emu->regs[_SP].dword[0]
src/include/regs.h:#define R_EBP emu->regs[_BP].dword[0]
src/include/regs.h:#define R_R8d emu->regs[_R8].dword[0]
src/include/regs.h:#define R_R9d emu->regs[_R9].dword[0]
src/include/regs.h:#define R_R10d emu->regs[_R10].dword[0]
src/include/regs.h:#define R_AX emu->regs[_AX].word[0]
src/include/regs.h:#define R_BX emu->regs[_BX].word[0]
src/include/regs.h:#define R_CX emu->regs[_CX].word[0]
src/include/regs.h:#define R_DX emu->regs[_DX].word[0]
src/include/regs.h:#define R_DI emu->regs[_DI].word[0]
src/include/regs.h:#define R_SI emu->regs[_SI].word[0]
src/include/regs.h:#define R_SP emu->regs[_SP].word[0]
src/include/regs.h:#define R_BP emu->regs[_BP].word[0]
src/include/regs.h:#define R_AL emu->regs[_AX].byte[0]
src/include/regs.h:#define R_AH emu->regs[_AX].byte[1]
src/include/regs.h:#define R_CL emu->regs[_CX].byte[0]
src/include/regs.h:#define R_CS emu->segs[_CS]
src/include/regs.h:#define R_DS emu->segs[_DS]
src/include/regs.h:#define R_SS emu->segs[_SS]
src/include/regs.h:#define R_ES emu->segs[_ES]
src/include/regs.h:#define R_FS emu->segs[_FS]
src/include/regs.h:#define R_GS emu->segs[_GS]
src/include/regs.h:#define ACCESS_FLAG(F)  emu->eflags.f._##F
src/include/regs.h:#define SET_FLAG(F)     emu->eflags.f._##F = 1
src/include/regs.h:#define CLEAR_FLAG(F)   emu->eflags.f._##F = 0
src/include/regs.h:#define CONDITIONAL_SET_FLAG(COND, F)   emu->eflags.f._##F = (COND)?1:0
